{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Chia-Tea \ud83c\udf3f\ud83c\udf75 Chia Tea is a command line tool and utility library for the Chia Cryptocurrency. We are building tools in this library to serve our own needs and share our work openly with others. Feel free to use them and make your life easier \ud83d\udc9a","title":"Home"},{"location":"#welcome-to-chia-tea","text":"Chia Tea is a command line tool and utility library for the Chia Cryptocurrency. We are building tools in this library to serve our own needs and share our work openly with others. Feel free to use them and make your life easier \ud83d\udc9a","title":"Welcome to Chia-Tea \ud83c\udf3f\ud83c\udf75"},{"location":"architecture_summary/","text":"Architecture Guide Disclaimer The codebase has evolved very drastically over the last months. This caused side-effects such as unneccesary functions, complex logic here or there or obscure classes, which haven't been refactored yet. Also testing is quite low, since the software architecure changed so much all the time, that it was too much effort to keep it up in the unstable parts of the code. On the road to our first stable release, we will take care of these aspects step by step. Copy-Plots This module contains code to copy plots from multiple source directories to multiple target directories. When choosing a disk it takes multiple factors into account such as how mandy plots are already being copied onto that drive. Also the entire process is quite fault-tolerant to disconnects or other issues. While it is not perfect, it does it's job very well for us. Monitoring Chia Watchdog The chia watchdog is the source of chia of data collection. It is also the oldest part of the code from a time before the monitoring layer was added. It consists of a single class ChiaWatchdog with additional class members. These classes are permanently modified by: logfile changes fetching data directly from chia via API calls self-checks run periodically This information is partially converted into protobuf messages and sent to the server. We don't send everything since some data is just for computations. For example we keep the signage point timestamps to check if a harvester missed a challenge but sending all that data is a waste. It makes more sense to simply send the amount of missed challenges and that's it. Protobuf Protocol The collected chia data needs to be sent from the monitoring clients to the monitoring server. The glue for this task is the communication protocol written in [Protobuf][protobuf]. This protocol defines two things: which data is sent from the monitored machines to the server but also what data is stored in the database. The protocol can be found in the folder protocol and the generated source code can be found under chia_tea.protobuf.generated . There is also a [GRPC][grpc] service definition, which defines the communication functions between server and client. The module chia_tea.monitoring.data_collection converts the ChiaWatchdog data into protobuf messages. It also contains the code to collect hardware information but this will be seperated in the future. Data Storage The library uses sqlite3 to store monitoring data on disk. There are two types of tables: There are two important tables: Update Event Table State Table The update event table stores all update events ever received for a topic. For example the CpuInfoEvents table contains all cpu data for all machines. To get a fast and easy overview over the current status there is also a state table. In case of the cpu this is CpuInfo . The state table is modified according to the update events, thus if a DELETE event for example is received an entry will be deleted. Table Schema The state table uses solely machine_id as primary key to distinguish entries whereas events also use timestamp and event_type . In case an entry is repeatable in protobuf such as a harvester reporting multiple plots for a single machine, then an additional field id is used as part of the primary key to distinguish data entries. Sqlite Schema Generation The module chia_tea.protobuf.to_sqlite is the bridge between protobuf and sqlite. It generically defines functions to store or retrieve protobuf messages from sqlite. The code is generic so that almost all changes made to the proto files are automatically handled. While the code works well, it requires severe refactoring to be more understandable and usable. Limitations are at the moment that enums as well as nested messages cannot be dealt with. Throttling The client only sends data if any changes occured. This is always the case for strongly varying metrics such as CPU usage. To avoid spamming the server and thus the database, the submission of such data is throttled in the client config under monitoring.client.send_update_every . We recommend to transmit such data no faster than once per minute. Important data such as harvester connectivity is not throttled at all and the event is transmitted once being captured. Connection Security The connection is secured by two certificates (.key and .cert). The filepaths are specified in the config.yml under monitoring.auth . While the monitoring server requires both files '.key' and '.cert', a client uses solely '.cert' to authenticate against the server. Database Version Compatability Since the database is generated from protobuf, changing the protocol may require to delete the old database since the tables are inconsistent. This will be addressed in the future.","title":"Architecture Guide"},{"location":"architecture_summary/#architecture-guide","text":"","title":"Architecture Guide"},{"location":"architecture_summary/#disclaimer","text":"The codebase has evolved very drastically over the last months. This caused side-effects such as unneccesary functions, complex logic here or there or obscure classes, which haven't been refactored yet. Also testing is quite low, since the software architecure changed so much all the time, that it was too much effort to keep it up in the unstable parts of the code. On the road to our first stable release, we will take care of these aspects step by step.","title":"Disclaimer"},{"location":"architecture_summary/#copy-plots","text":"This module contains code to copy plots from multiple source directories to multiple target directories. When choosing a disk it takes multiple factors into account such as how mandy plots are already being copied onto that drive. Also the entire process is quite fault-tolerant to disconnects or other issues. While it is not perfect, it does it's job very well for us.","title":"Copy-Plots"},{"location":"architecture_summary/#monitoring","text":"","title":"Monitoring"},{"location":"architecture_summary/#chia-watchdog","text":"The chia watchdog is the source of chia of data collection. It is also the oldest part of the code from a time before the monitoring layer was added. It consists of a single class ChiaWatchdog with additional class members. These classes are permanently modified by: logfile changes fetching data directly from chia via API calls self-checks run periodically This information is partially converted into protobuf messages and sent to the server. We don't send everything since some data is just for computations. For example we keep the signage point timestamps to check if a harvester missed a challenge but sending all that data is a waste. It makes more sense to simply send the amount of missed challenges and that's it.","title":"Chia Watchdog"},{"location":"architecture_summary/#protobuf-protocol","text":"The collected chia data needs to be sent from the monitoring clients to the monitoring server. The glue for this task is the communication protocol written in [Protobuf][protobuf]. This protocol defines two things: which data is sent from the monitored machines to the server but also what data is stored in the database. The protocol can be found in the folder protocol and the generated source code can be found under chia_tea.protobuf.generated . There is also a [GRPC][grpc] service definition, which defines the communication functions between server and client. The module chia_tea.monitoring.data_collection converts the ChiaWatchdog data into protobuf messages. It also contains the code to collect hardware information but this will be seperated in the future.","title":"Protobuf Protocol"},{"location":"architecture_summary/#data-storage","text":"The library uses sqlite3 to store monitoring data on disk. There are two types of tables: There are two important tables: Update Event Table State Table The update event table stores all update events ever received for a topic. For example the CpuInfoEvents table contains all cpu data for all machines. To get a fast and easy overview over the current status there is also a state table. In case of the cpu this is CpuInfo . The state table is modified according to the update events, thus if a DELETE event for example is received an entry will be deleted.","title":"Data Storage"},{"location":"architecture_summary/#table-schema","text":"The state table uses solely machine_id as primary key to distinguish entries whereas events also use timestamp and event_type . In case an entry is repeatable in protobuf such as a harvester reporting multiple plots for a single machine, then an additional field id is used as part of the primary key to distinguish data entries.","title":"Table Schema"},{"location":"architecture_summary/#sqlite-schema-generation","text":"The module chia_tea.protobuf.to_sqlite is the bridge between protobuf and sqlite. It generically defines functions to store or retrieve protobuf messages from sqlite. The code is generic so that almost all changes made to the proto files are automatically handled. While the code works well, it requires severe refactoring to be more understandable and usable. Limitations are at the moment that enums as well as nested messages cannot be dealt with.","title":"Sqlite Schema Generation"},{"location":"architecture_summary/#throttling","text":"The client only sends data if any changes occured. This is always the case for strongly varying metrics such as CPU usage. To avoid spamming the server and thus the database, the submission of such data is throttled in the client config under monitoring.client.send_update_every . We recommend to transmit such data no faster than once per minute. Important data such as harvester connectivity is not throttled at all and the event is transmitted once being captured.","title":"Throttling"},{"location":"architecture_summary/#connection-security","text":"The connection is secured by two certificates (.key and .cert). The filepaths are specified in the config.yml under monitoring.auth . While the monitoring server requires both files '.key' and '.cert', a client uses solely '.cert' to authenticate against the server.","title":"Connection Security"},{"location":"architecture_summary/#database-version-compatability","text":"Since the database is generated from protobuf, changing the protocol may require to delete the old database since the tables are inconsistent. This will be addressed in the future.","title":"Database Version Compatability"},{"location":"faq/","text":"Why Chia-Tea? First and most important we love tea \ud83c\udf75 and we are not talking about that heartless, average stuff. We talk about tea with full-hearted passion and character in it. In this way we also love to craft software. Second, we started the library from a single utility script to maintain our hobby chia farm. The project grew over time into a fully fledged chia library. Since we found it especially hard to keep track of our infrastructure, we designed a monitoring solution for our farm. What are important commands for Chia-Tea? We have a Command Line Interface (CLI) called chia-tea. It contains all important commands. For more information see the Quick-Start Guide . What can the discord bot do? Notify on: [x] Farmer: Harvester connection/disconnection [x] Harvester timeout [x] Harvester looses plots [x] Harvester: Notify on reward [x] Wallet connects/disconnects [x] Wallet syncing or loosing sync [x] Computer has full RAM [x] Computer looses a disk [x] Computer timeouts Commands: [x] $machines : info about all machines known to the monitoring [x] $harvesters : reports the status of all connected harvesters [x] $wallets : reports the status of all wallets [x] $farmers : reports the status of all farmers [x] $sql : execute an arbitrary sql cmd on the database (read only) [x] $plotters : reports on running plotters and their progress [x] $fullnodes : reports the status of all full nodes being monitored How does the monitoring work? Reconsider the structure of this repository In both use scenarios, you in total need three programs to run: client: collects all data on a machine server: receives all data from connected machines and stores it discord bot: provides interaction with the database On a single machine setup you will run every task on this particular machine. If you are running a multiple machine setup you can run the monitoring and server task on one machine whereas on all other machines you will run the client task. Client To collect data from a system simply run the client on the very same machine. It collects data from automatically and send it to the server. This is a lot of information ranging from down-to-earth ram usage to checks if e.g. a farmer is running to information about every plot of a harvester. Server The server receives the client data and writes it into a database file. This database file stores all events which ever happened. You can use this database to build anything on top, such as a dashboard. Discord Bot Our discord bot watches the database for changes and provides notifications in case something is up. For example if you loose a drive with plots on or if the wallet is not synced anymore. Also there are commands to check on the status of different things. What data is being collected? Briefly answered, everything relevant. Hardware information such as CPU, RAM, Disks but also system rsources such as chia specific processes. We don't monitor absolutely everything (we value a healthy privacy). If nothing specific to chia is present on the system the monitoring will simply omit this data. Hardware CPU [x] name [x] n_cores [x] clock_speed [x] usage [x] temperature (depends on machine) RAM [x] total/used ram [x] total/used swap Disks [ ] temperature (cannot get without admin rights) [x] total/used space [ ] read/write activity (cannot get without admin rights) [ ] read/write speed (cannot get without admin rights) [ ] read/write total tbw (cannot get without admin rights) [x] device name [x] mountpoint [x] fstype [x] mount options Chia Farmer [x] is running [ ] total challenges [x] connected harvester [x] time of connect [x] time of last msg [x] ip address [x] disconnects [x] missed challenges [x] proofs found [x] number of plots Harvester [x] is running [x] plots with details [x] public key (id) [x] filename [x] filesize [x] pool contract puzzle hash [x] size (e.g. 32 for k32) [x] time modified [x] plot seed [ ] disk id Wallet [x] is running [x] is synced Full Node [x] is running [x] is synced [x] sync node height [x] sync blockchain height Plotters (MadMax) [x] plotting process [x] plots in process [x] public key (id) [x] pool_public_key [x] start time [x] progress in percent [x] plotting stage name Chia-related processes [x] process name, executable, command [x] process id [x] creation time [x] cpu usage [x] ram usage [x] opened files [ ] network connections (quite verbose data)","title":"FAQ"},{"location":"faq/#why-chia-tea","text":"First and most important we love tea \ud83c\udf75 and we are not talking about that heartless, average stuff. We talk about tea with full-hearted passion and character in it. In this way we also love to craft software. Second, we started the library from a single utility script to maintain our hobby chia farm. The project grew over time into a fully fledged chia library. Since we found it especially hard to keep track of our infrastructure, we designed a monitoring solution for our farm.","title":"Why Chia-Tea?"},{"location":"faq/#what-are-important-commands-for-chia-tea","text":"We have a Command Line Interface (CLI) called chia-tea. It contains all important commands. For more information see the Quick-Start Guide .","title":"What are important commands for Chia-Tea?"},{"location":"faq/#what-can-the-discord-bot-do","text":"Notify on: [x] Farmer: Harvester connection/disconnection [x] Harvester timeout [x] Harvester looses plots [x] Harvester: Notify on reward [x] Wallet connects/disconnects [x] Wallet syncing or loosing sync [x] Computer has full RAM [x] Computer looses a disk [x] Computer timeouts Commands: [x] $machines : info about all machines known to the monitoring [x] $harvesters : reports the status of all connected harvesters [x] $wallets : reports the status of all wallets [x] $farmers : reports the status of all farmers [x] $sql : execute an arbitrary sql cmd on the database (read only) [x] $plotters : reports on running plotters and their progress [x] $fullnodes : reports the status of all full nodes being monitored","title":"What can the discord bot do?"},{"location":"faq/#how-does-the-monitoring-work","text":"Reconsider the structure of this repository In both use scenarios, you in total need three programs to run: client: collects all data on a machine server: receives all data from connected machines and stores it discord bot: provides interaction with the database On a single machine setup you will run every task on this particular machine. If you are running a multiple machine setup you can run the monitoring and server task on one machine whereas on all other machines you will run the client task.","title":"How does the monitoring work?"},{"location":"faq/#client","text":"To collect data from a system simply run the client on the very same machine. It collects data from automatically and send it to the server. This is a lot of information ranging from down-to-earth ram usage to checks if e.g. a farmer is running to information about every plot of a harvester.","title":"Client"},{"location":"faq/#server","text":"The server receives the client data and writes it into a database file. This database file stores all events which ever happened. You can use this database to build anything on top, such as a dashboard.","title":"Server"},{"location":"faq/#discord-bot","text":"Our discord bot watches the database for changes and provides notifications in case something is up. For example if you loose a drive with plots on or if the wallet is not synced anymore. Also there are commands to check on the status of different things.","title":"Discord Bot"},{"location":"faq/#what-data-is-being-collected","text":"Briefly answered, everything relevant. Hardware information such as CPU, RAM, Disks but also system rsources such as chia specific processes. We don't monitor absolutely everything (we value a healthy privacy). If nothing specific to chia is present on the system the monitoring will simply omit this data. Hardware CPU [x] name [x] n_cores [x] clock_speed [x] usage [x] temperature (depends on machine) RAM [x] total/used ram [x] total/used swap Disks [ ] temperature (cannot get without admin rights) [x] total/used space [ ] read/write activity (cannot get without admin rights) [ ] read/write speed (cannot get without admin rights) [ ] read/write total tbw (cannot get without admin rights) [x] device name [x] mountpoint [x] fstype [x] mount options Chia Farmer [x] is running [ ] total challenges [x] connected harvester [x] time of connect [x] time of last msg [x] ip address [x] disconnects [x] missed challenges [x] proofs found [x] number of plots Harvester [x] is running [x] plots with details [x] public key (id) [x] filename [x] filesize [x] pool contract puzzle hash [x] size (e.g. 32 for k32) [x] time modified [x] plot seed [ ] disk id Wallet [x] is running [x] is synced Full Node [x] is running [x] is synced [x] sync node height [x] sync blockchain height Plotters (MadMax) [x] plotting process [x] plots in process [x] public key (id) [x] pool_public_key [x] start time [x] progress in percent [x] plotting stage name Chia-related processes [x] process name, executable, command [x] process id [x] creation time [x] cpu usage [x] ram usage [x] opened files [ ] network connections (quite verbose data)","title":"What data is being collected?"},{"location":"quick_start/","text":"Chia-Tea Quick Start This guide is for getting started using Chia-Tea. Table of Contents What can I do with Chia-Tea? How to install Chia-Tea? How to configure Chia-Tea? How to start the copy tool? How to monitor my farm? What can I do with Chia-Tea? There are currently three major use-cases: Copy plots between drives Monitoring of a single or multi-machine chia farm Discord bot to give notifications and allow interaction How to install Chia-Tea? You can install it as usualy by using the python package manager: python -m pip install chia-tea Alternatively you can also clone the repo and install the code manually: git clone https://github.com/Tea-n-Tech/chia-tea.git python -m pip install poetry python -m poetry install python -m poetry build python -m pip install dist/*.whl How to configure Chia-Tea? To create a config simply run: chia-tea config init All configurations are stored in a config.yml file. Every cli tools uses this config and searches by default for a file ~/.chia_tea/config/config.yml . You can get the path to the config by running chia-tea config location If you create the config in another location, you can also specify the path to the config by using the --config option for every start command. After creating the config and possibly adapting it, you can start processes as listed below. How to start the copy tool? You can start the copy tool with: chia-tea start copy It will then copy plots between the copy.source_folders drives to the copy.target_folders drives as specified in the config.yml . How to monitor my farm? You initialized already the config but also need certificates to secure the connection between server and client. To create the certificates simply run: chia-tea config create-certificates And they will be created next to the config. The certificates work by default only on your machine! If you have a setup over a network, you must specify the monitoring server name with the option --common-name or you will get a No match found for server name error on the server when clients try to connect to it. The server name can be the ip address or a url. As a note, the client only requires the .crt certificate file and not the private .key file. The monitoring server receives all monitoring data and stores it in a file called monitoring.db , but this can be changed in the config under monitoring.server.db_filepath . You can start the server now by running: chia-tea start monitoring-server After starting a server you can connect an arbitrary amount of clients to it. Clients are programs run on machines you want to monitor. A client collects data from the hardware, processes and chia and sends it to the server. You can control the the data collection frequency in the config under monitoring.client but the default should suffice for the beginning. Simply run the following command and Chia-Tea will collect and send all data automatically to the server: chia-tea start monitoring-client We have a discord bot as a user interface to the database. It will notify you on any important events and provide commands to get further insights. Before you can run the bot you will need a Discord Bot Token and also the id of your channel. Specify this once again in the config.yml under discord . You can run the bot with: chia-tea start discord-bot And here you go, you are all set up.","title":"Quick-Start"},{"location":"quick_start/#chia-tea-quick-start","text":"This guide is for getting started using Chia-Tea.","title":"Chia-Tea Quick Start"},{"location":"quick_start/#table-of-contents","text":"What can I do with Chia-Tea? How to install Chia-Tea? How to configure Chia-Tea? How to start the copy tool? How to monitor my farm?","title":"Table of Contents"},{"location":"quick_start/#what-can-i-do-with-chia-tea","text":"There are currently three major use-cases: Copy plots between drives Monitoring of a single or multi-machine chia farm Discord bot to give notifications and allow interaction","title":"What can I do with Chia-Tea?"},{"location":"quick_start/#how-to-install-chia-tea","text":"You can install it as usualy by using the python package manager: python -m pip install chia-tea Alternatively you can also clone the repo and install the code manually: git clone https://github.com/Tea-n-Tech/chia-tea.git python -m pip install poetry python -m poetry install python -m poetry build python -m pip install dist/*.whl","title":"How to install Chia-Tea?"},{"location":"quick_start/#how-to-configure-chia-tea","text":"To create a config simply run: chia-tea config init All configurations are stored in a config.yml file. Every cli tools uses this config and searches by default for a file ~/.chia_tea/config/config.yml . You can get the path to the config by running chia-tea config location If you create the config in another location, you can also specify the path to the config by using the --config option for every start command. After creating the config and possibly adapting it, you can start processes as listed below.","title":"How to configure Chia-Tea?"},{"location":"quick_start/#how-to-start-the-copy-tool","text":"You can start the copy tool with: chia-tea start copy It will then copy plots between the copy.source_folders drives to the copy.target_folders drives as specified in the config.yml .","title":"How to start the copy tool?"},{"location":"quick_start/#how-to-monitor-my-farm","text":"You initialized already the config but also need certificates to secure the connection between server and client. To create the certificates simply run: chia-tea config create-certificates And they will be created next to the config. The certificates work by default only on your machine! If you have a setup over a network, you must specify the monitoring server name with the option --common-name or you will get a No match found for server name error on the server when clients try to connect to it. The server name can be the ip address or a url. As a note, the client only requires the .crt certificate file and not the private .key file. The monitoring server receives all monitoring data and stores it in a file called monitoring.db , but this can be changed in the config under monitoring.server.db_filepath . You can start the server now by running: chia-tea start monitoring-server After starting a server you can connect an arbitrary amount of clients to it. Clients are programs run on machines you want to monitor. A client collects data from the hardware, processes and chia and sends it to the server. You can control the the data collection frequency in the config under monitoring.client but the default should suffice for the beginning. Simply run the following command and Chia-Tea will collect and send all data automatically to the server: chia-tea start monitoring-client We have a discord bot as a user interface to the database. It will notify you on any important events and provide commands to get further insights. Before you can run the bot you will need a Discord Bot Token and also the id of your channel. Specify this once again in the config.yml under discord . You can run the bot with: chia-tea start discord-bot And here you go, you are all set up.","title":"How to monitor my farm?"}]}